# ozzo-routing

[![GoDoc](https://godoc.org/github.com/go-ozzo/ozzo-routing?status.png)](http://godoc.org/github.com/go-ozzo/ozzo-routing)
[![Build Status](https://travis-ci.org/go-ozzo/ozzo-routing.svg?branch=master)](https://travis-ci.org/go-ozzo/ozzo-routing)
[![Coverage](http://gocover.io/_badge/github.com/go-ozzo/ozzo-routing)](http://gocover.io/github.com/go-ozzo/ozzo-routing)

ozzo-routing это Go-пакет, обеспечивающий поддержку маршрутизации и обработки для Web приложений.
Он включает в себя:

* middleware pipeline архитектуру, подобную [Express framework](http://expressjs.com).
* высокую расширяемость при помощи подключемых обработчиков (middlewares)
* модульную организацию кода через группировку маршрутов
* внедрение зависимостей (dependency injection) для внедрения параметров в обработчики
* воможность использовать URL с параметрами
* файловый сервер для статического контента (static file server) для файлов: js, png, jpg, html и так далее.
* обработчик ошибок (error handling)
* совместимость с нативными `http.Handler` и `http.HandlerFunc`

## Требования

Go 1.2 или выше.

## Установка

Выполните указанные команды для установки пакета:

```
go get github.com/go-ozzo/ozzo-routing
```

## С чего начать

Создайте файл `server.go` с таким содержимым:

```go
package main

import (
	"fmt"
	"log"
	"net/http"
	"github.com/go-ozzo/ozzo-routing"
)

func main() {
	r := routing.NewRouter()

	// установка часто используемых middlewares (связующее ПО)
	r.Use(
		routing.AccessLogger(log.Printf),
		routing.TrailingSlashRemover(http.StatusMovedPermanently),
	)

	// настройка маршрутов и обработчиков
	r.Get("", func() string {
		return "Go ozzo!"
	})
	r.Get("/users", func() string {
		return "getting users"
	})
	r.Group("/admin", func(gr *routing.Router) {
        gr.Post("/users", func() string {
            return "creating users"
        })
        gr.Delete("/users", func() string {
            return "deleting users"
        })
	})

	// обработка запроса не совпавшего ни с одим из зарегистрированных маршрутов
	r.Use(routing.NotFoundHandler())

	// обработка ошибок выкинутых обработчиками
	r.Error(routing.ErrorHandler(nil))

	// тут подключаем маршрутизатор и запускаем Go Web сервер
	http.Handle("/", r)
	http.ListenAndServe(":8080", nil)
}
```

Далее выполите команды для запуска Web сервера:

```
go run server.go
```

Теперь вы можете получить доступ по адресам URL, таким как `http://localhost:8080`, `http://localhost:8080/users`.


## Дерево маршрутизации

ozzo-routing работает при помощи создания дерева маршрутизации *routing tree*, распределяя HTTP запросы по обработчикам на этом дереве.

Конечный узел на дереве маршрутов называется *route*, в то время как промежуточныый называется *router*. На каждом узле
(конечном или промежуточном), имеется список обработчиков *handlers* (также известных как middlewares), которые содержат логику
для обработки HTTP запросов.

Диспетчеризация входящих HTTP запросов начинается с корня дерева маршрутизации и далее обход идет в глубину.
HTTP методы и части URL используются для задания соответствия узлов дерева. Обработчики для совпадающих узлов будут вызываться
в соответствии с порядком узла и порядком следования зарегистрированного обработчика для этого узла.
Обработчик должен вызывать либо `Context.Next()` или `Context.NextRoute()` чтобы передать управление на следующий разрешенный обаботчик. В противном случае обработка запроса считается завершенной и дальнейшие обработчики вызываться не будут.

Для построения дерева маршрутизации, сначала выполните `routing.NewRouter()` для создания корневого узла. Затем выполните `Router.To()`, `Router.Get()`, `Router.Post()`, и так далее для создания оконечных узлов (листьев), или вызовете `Router.Group()` для создания промежуточного узла. Например,

```go
// корневой узел
r := routing.NewRouter()

// листья (маршруты)
r.Get("", handler1, handler2, ...)
r.Get("/users", handler1, handler2, ...)

// внутренний узел (дочерние маршрутизаторы)
r.Group("/admin", func(r *routing.Router) {
    // листья на внутреннем узле (дочернем маршрутизаторе)
    r.Post("/users", handler1, handler2, ...)
    r.Delete("/users", handler1, handler2, ...)
})
```

В следствие того что `Router` реализует `http.Handler`, он может быть легко использован для обслуживания поддеревьев на существующих Go серверах.
Например,

```go
http.Handle("/", r)
http.ListenAndServe(":8080", nil)
```


## Маршруты

Маршрут содержит некий шаблон пути, который используется для соответствия URL входящего запроса и его обработчика. Только соответствующие определенному шаблону запросы могут быть направлены по соответствующему маршруту. Например, шаблон `/users` соответствует любому запросу с URL чей путь соответствует `/users`.
Регулярные выражения также могут быть использованы в шаблоне. Например, шаблон `/users/\\d+` соответствует URL запросу `/users/123`,
но не `/users` или `/users/abc`.

Опционально маршрут может содержать один или несколько HTTP методов (таких как `GET`, `POST`) таким образом, что только запросы, использующие один из таких методов HTTP, могут быть оправлены по маршруту.

Маршрут обычно ассоциируется с одним или несколькими обработчиками. Когда при разборе запроса обнаружется совпадение маршрутов, 
их обработчики будут вызваны.

Вы можете создать или добавить новый маршрут к дереву маршрутизации с помощью вызова `Router.To()` или одного из его укороченных методов, таких как `Router.Use()`, `Router.Get()`. Например,

```go
r := routing.New()

r.To("GET /users", func() { })

// что эквивалентно использованию метода Get()
r.Get("/users", func() { })
```

Приведенный выше код добавляет маршрут, который соответствует пути URL `/users` и применяется только к HTTP методу GET. Также вы можете вызывать `Post()`, `Put()`, `Patch()`, `Head()`, или `Options()` для вызова прочих HTTP методов.

Если маршрут должен использовать несколько методов HTTP, вы можете использовать синтаксис, как показано ниже:

```go
// соответствует только GET или POST
r.To("GET,POST /users", func() { })

// применяется для обработки любого метода HTTP
r.To("/users", func() { })
```

Если маршрут должен соответствовать *любому запросу*, вызывайте `Router.Use()` как указано ниже:

```go
r.Use(func() { })
```


### Параметры URL

Шаблон, который определен для маршрута, может быть использован для сбора параметров из строки URL путем встраивания маркеров в формат в виде `<имя:шаблон>`, где `имя` означает имя параметра, а `шаблон` является регулярным выражением, с которым должно совпадать значение параметра. Вы можете опустить часть `шаблон`, что будет означать что параметру должна соответствовать непустая строка без символа слэша.

Когда маршрут соответствует пути URL, параметры из URL будут доступны через `Context.Params`. Например,

```go
r := routing.NewRouter()

r.To("GET /cities/<name>", func (c *routing.Context) {
    fmt.Fprintf(c.Response, "Name: %v", c.Params["name"])
})

r.To("GET /users/<id:\\d+>", func (c *routing.Context) {
    fmt.Fprintf(c.Response, "ID: %v", c.Params["id"])
})
```


## Обработчики

Обработчики - это самые обычные вызываемые функции. Обработчик вызывается, когда запрос отправляется на маршрут или маршрутизатор, с которым связан данный обработчик.

В обработчике вы можете вызвать `Context.Next()` чтобы передать управление на следующий доступный обработчик по тому же самому маршруту или первому обработчику на следующем совпадающем маршруте.
Также вы можете вызвать `Context.NextRoute()` чтобы сразу вызвать обработчик следующего совпадающего маршрута.

Обычно обработчики выступающие в качестве фильтра должны вызывать `Context.Next()`, чтобы следующие за ними обработчики смогли
обработать запрос. Обработчики, которые являются контроллерами действий обычно не должны вызывать `Context.Next()` т.к. 
они являются последним этапом обработки запроса.
`Context.NextRoute()` часто используются обаботчиками для определения что текущий маршрут или роутер используется для отправки запроса.
Например,

```go
r := routing.NewRouter()
r.Get("/users", func(c *routing.Context) {
    fmt.Fprintln(c.Response, "/users1 start")
    c.Next()
    fmt.Fprintln(c.Response, "/users1 end")
}, func(c *routing.Context) {
    fmt.Fprintln(c.Response, "/users2 start")
    c.Next()
    fmt.Fprintln(c.Response, "/users2 end")
})

r.Get("/users", func(c *routing.Context) {
    fmt.Fprintln(c.Response, "/users3")
})

r.Get("/users", func(c *routing.Context) {
    fmt.Fprintln(c.Response, "/users4")
})
```

При обработке строки URL `/users` дерева маршрутизации, выведется следующий текст:

```
/users1 start
/users2 start
/users3
/users2 end
/users1 end
```

Заметьте, что `/user4` не отображается потому, что разбор запроса прекращается после отображения `/user3`.
Также обратите внимание, что выходы обработчиков вложены правильно.


### Контекст

Для каждого входящего запроса, создается новый экземпляр `routing.Context`, в который включается контекстная информация для входящего запроса, такая как текущий запрос, ответ, и т.д. Обработчик может получить доступ к текущему `Контексту` объявив параметр `*routing.Context`, как описано ниже:

```go
func (c *routing.Context) {
}
```

Используя `Контекст`, обработчики могут обмениваться данными между собой. Простой способ заключается в использовани поля `Context.Data`.
Например один обработчик сохраняет данные в поле `Context.Data["user"]`, которое будет доступно для другого обработчика. Более продвинутый способ заключается в использовании `Контекста` как инъекции зависимостей с использованием (DI) контейнера. В частности, один обработчик регистрирует данные которые должны быть доступны для совместного использования (такие как кеш) с `Контекстом`, а другой обработчик объявляет параметр того же типа данных.
Затем через внедрение зависимостей из `Context`, следующий обработчик сможет принять данные как свой параметр. Например,

```go
r := routing.NewRouter()
r.Use(func (c *routing.Context) {
    // используя Context.Data для обмена данными
    c.Data["db"] = &Database{}

    // используя dependency injection для обмена данными
    c.Register(&Cache{})
})
r.Use(func (c *routing.Context, cache *Cache) {
    // доступ из c.Data["db"]

    // cache уже внедрен и доступен здесь
})
```

> Информация: Когда обработчик получает параметр `*routing.Context`, его значение также получается при помощи внедрения зависимостей (dependency injection).

### Ответ и возвращаемые значения

Очень часто обрабочкик должен послать в ответ некие данные. Это может быть сделано с использованием следующего кода:

```go
func (c *routing.Context) {
    fmt.Fprint(c.Response, "Hello world")
}
```

Как альтернатива, вы можете вернуть данные как возвращаемое значение функции обработчика. Перепишем код выше для иллюстрации примера:

```go
func () string {
    return "Hello world"
}
```

Вы можете вернуть данные произвольной структуры, а не только строковое значение. Маршрутизатор должен преобразовать принятые данные в строку под средством вызова `fmt.Fprint()`. Также вы можете настроить форматирование данных путем замены `Context.Response` с использованием объекта response, который имплементирует интерфейс `DataWriter`.


### Встроенные обработчики

ozzo-routing поставляется с несколькими часто используемыми обработчиками:

* `routing.ErrorHandler`: обработчик ошибок
* `routing.NotFoundHandler`: обработчик для ошибки 404 HTTP
* `routing.TrailingSlashRemover`: обработчик удаления замыкающих слешей из URL запроса
* `routing.AccessLogger`: обработчик для логирования входящих запросов
* `routing.Static`: обработчик для отдачи статического контента из указанной папки
* `routing.StaticFile`: обработчик для отдачи содержимого указанного файла

Эти обработчики могут быть использованы так:

```go
r := routing.NewRouter()

r.Use(
    routing.AccessLogger(log.Printf),
    routing.TrailingSlashRemover(http.StatusMovedPermanently),
)

// ... регистрация маршрутизаторов и обработчиков

r.Use(routing.NotFoundHandler())

r.Error(routing.ErrorHandler(nil))
```

Дополнительные обработчики для сервисов RESTful API можно найти в
[ozzo-rest Go-пакете](https://github.com/go-ozzo/ozzo-rest).


### Сторонние обработчики

ozzo-routing поддерживает сторонние обработчики через `http.HandlerFunc` и `http.Handler`. Их можно легко использовать при момощи адаптеров. Например,

```go
r := routing.NewRouter()

// используя http.HandlerFunc
r.Use(routing.HTTPHandlerFunc(http.NotFound))

// используя http.Handler
r.Use(routing.HTTPHandler(http.NotFoundHandler))
```

## Группировка маршрутов

Маршруты с одинаковыми URL могут быть сгруппированы при помощи `Router.Group()`. Поддержка группировки маршрутов позволяет создавать модульную архитектуру вашего приложения. Например, если вы имеете модуль `admin` который использует группу маршрутов `/admin`, как общую часть URL префикса, то сответствующая маршрутизация может быть настроена так:

```go
r := routing.NewRouter()

// ...прочие маршруты...

// группа /admin
r.Group("/admin", function(gr *routing.Router) {
    gr.Post("/users", func() { })
    gr.Delete("/users", func() { })
    // ...
})
```

Обратите внимание, что при задании группы маршрутов, общий URL префикс ("/admin") должен быть удален из шаблона, как показано на примере выше.

Вы можете задать несколько уровней групп маршрутизации. На самом деле, как мы обяснили раньше, вся маршрутизация строится как древовидная струкура, которая позволяет организовать ваш код в виде иерархических модулей.

## Обслуживание статических файлов

Статические файлы могут быть отданы через стандартные обаботчики `routing.Static` или `routing.StaticFile`. Первый используется для отдачи файла из указанной папки с файлами в соответствии с текущим запросом, а второй для конкретного заданного файла. Например,

```go
r := routing.NewRouter()
// отдает файлы из папки working-dir/web/assets
r.To("/assets(/.*)?", routing.Static("web"))
```


## Обработка ошибок

ozzo-routing поддерживает обработку возникающих ошибок через обработчики ошибок. Обработчик ошибок, это обработчик, который зарегистрирован через метод `Router.Error()`. Когда в обработчике возникает `паника`, роутер обрабатывает это состояние при помощи вызова обработчика ошибок, зарегистрированного ниже текущего маршрута. Все обычные обработчики, находящиемя между ними, пропускаются.

Обработчик ошибок может получить информацию об ошибке из `Context.Error`. Как и обычные обработчики, обработчики ошибок могут получать необходимую информацию при помощи внедрения зависимостей (dependency injection). Например,

```go
r := routing.NewRouter()

// ...здесь регистрируются маршруты и их обработчики

r.Error(func(c *routing.Context) {
    fmt.Println(c.Error)
})
```

Если зарегистрированы несколько обработчиков ошибок, то вы можете вызвать `Context.Next()` для того чтобы передать управление следующему обработчику.

Для удобства `Context` предоставляет метод `Panic()`, применяемый для того, чтобы упростить выброс ошибок HTTP.
Например,

```go
func (c *routing.Context) {
    c.Panic(http.StatusNotFound)
    // это эквивалентно вызову кода
    // panic(routing.NewHTTPError(http.StatusNotFound))
}
```


## Реализация структуры MVC

ozzo-routing может быть использована, чтобы легко рализовать Контроллер из структуры паттерна MVC.
Например,

```go
// server.go file:
...
r := routing.NewRouter()
...
r.Group("/users", users.Routes)
...

// файл users/controller.go:
package users
...
func Routes(r *routing.Router) {
	r.Get("", Controller.index)
	r.Get("/<id:\\d+>", Controller.view)
	...
}

type Controller struct {
	*routing.Context `inject`
}

func (c Controller) index() string {
	return "index"
}

func (c Controller) view() string {
	return "view" + c.Params["id"]
}

...
```

## Признательность

ozzo-routing схож по реализации, как в [Express](http://expressjs.com/), [Martini](https://github.com/go-martini/martini),
и многих подобных проектах.
